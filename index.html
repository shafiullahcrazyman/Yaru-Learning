<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Manifest for Android/Chrome -->
<link rel="manifest" href="manifest.json">

<!-- iOS / Safari Home Screen -->
<link rel="apple-touch-icon" href="icon.png">

<!-- Favicon fallback -->
<link rel="icon" href="icon.png">

<!-- Theme colors -->
<meta name="theme-color" content="#161616">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Yaru Learning">
    <title>Yaru Learning by Shafiullah</title>
    <style>
        /* --- Global & Mobile-First Styles (Fixed Input) --- */
        :root {
            --background-color: #1a1a1a; 
            --text-color: #f0f0f0;      
            --primary-color: #79a6d9;    
            --secondary-color: #b798d1;  
            --card-bg: #1a1a1a;          
            --border-color: #444;        
            --correct-color: #588157;    
            --completed-color: #3e4451; 
            --incorrect-color: #d85757;  
            --input-bar-height: 95px; 
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0; 
            background-color: var(--background-color);
            color: var(--text-color);
            
            display: flex;
            flex-direction: column;
            height: 100vh;
            
            -webkit-tap-highlight-color: transparent;
        }

        .app-container {
            /* Changed from 20px padding to 0 */
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
            margin: 0 auto; 
            padding: 0; 
        }
        
        /* Scrollable Content Wrapper */
        .content-wrapper {
            flex-grow: 1; 
            overflow-y: auto; 
            padding-bottom: var(--input-bar-height); 
            width: 100%;
            /* Added padding here for content spacing */
            padding-left: 20px; 
            padding-right: 20px;
            box-sizing: border-box;
        }

        /* Fixed Input Bar (The Footer) */
        .fixed-input-bar {
            position: fixed; 
            bottom: 0;
            left: 0;
            right: 0;
            height: var(--input-bar-height);
            background-color: var(--card-bg);
            box-shadow: none; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            box-sizing: border-box;
            max-width: 500px; 
            margin: 0 auto; 
        }

        /* Window Styles */
        .window {
            background-color: var(--card-bg); 
            border-radius: 12px;
            box-shadow: none; 
            /* Removed padding from here */
            padding: 0; 
            box-sizing: border-box;
            transition: opacity 0.3s ease;
        }

        .window:not(.active) {
            display: none;
            opacity: 0;
        }
        
        /* --- NEW: Header and Back Button Styles (Shared) --- */
        .window-header {
            display: flex;
            align-items: center;
            justify-content: space-between; 
            padding: 25px 0 0 0; /* Add top padding to the header */
            box-sizing: border-box;
            width: 100%;
            margin-bottom: 10px; 
            /* Negative margin to counteract content-wrapper padding, then re-pad */
            margin-left: -20px; 
            padding-left: 40px; /* 20px (wrapper offset) + 20px (content padding) */
            padding-right: 20px;
        }

        .back-button {
            font-size: 2em;
            font-weight: bold;
            color: var(--text-color);
            cursor: pointer;
            padding-right: 15px; 
            line-height: 1; 
            transition: color 0.1s ease;
            user-select: none; 
        }
        .back-button:hover {
            color: var(--primary-color);
        }

        /* Title style for the window header (h2) */
        .window-header h2 {
            flex-grow: 1; 
            text-align: center; 
            color: var(--primary-color);
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        /* --- Tutorial/Initial Screen Titles --- */
        /* Hide the new header content when in tutorial mode */
        #lesson-window.tutorial #lesson-header {
            display: none !important; /* Use !important to override JS and flex */
        }
        /* Hide the static titles when in lesson mode */
        #lesson-window:not(.tutorial) h1, 
        #lesson-window:not(.tutorial) h3 {
             display: none;
        }
        /* Show the static titles when in tutorial mode */
        #lesson-window.tutorial h1 {
            color: var(--primary-color);
            margin: 0;
            font-size: 1.5em;
            font-weight: bold;
            text-align: center;
            padding: 25px 0 0 0; /* Add top padding to the centered h1 */
        }
        #lesson-window.tutorial h3 {
            font-size: 1.1em; 
            margin-bottom: 20px;
            color: #aaa;
            text-align: center;
            padding: 0; 
        }
        /* --- END Title Styles --- */
        
        .sentence-display {
            font-size: 2em;
            text-align: justify; 
            margin-bottom: 25px;
            line-height: 1.7;
            cursor: default;
            padding: 0; 
        }
        
        /* Specific styles for the tutorial section */
        #tutorial-content {
            font-size: 0.9em; 
            line-height: 1.6;
            padding: 0;
            text-align: left;
        }
        #tutorial-content h5 {
            color: var(--primary-color);
            margin-top: 25px;
            margin-bottom: 10px;
            font-size: 1em;
        }
        #tutorial-content ol {
            padding-left: 20px;
            margin-top: 0;
            color: #ccc;
        }
        #tutorial-content strong {
            color: var(--text-color);
        }
        
        .sentence-display ruby { margin-right: 0.2em; } 
        .sentence-display rt { font-size: 0.4em; color: #aaa; user-select: none; }
        
        /* Segment Styles (The Word) */
        .segment { 
            position: relative; 
            cursor: pointer; 
            transition: background-color 0.1s ease; 
        }
        
        /* Highlight for correctly typed segments (green) */
        .segment.correct { 
            background-color: var(--correct-color); 
            border-radius: 5px; 
            transition: background-color 0.2s ease; 
            padding: 0 3px; 
            margin: 0 -3px; 
        }

        /* Highlight for completed segments (subtle gray/blue) */
        .segment.completed {
            background-color: var(--completed-color);
            border-radius: 5px; 
            padding: 0 3px; 
            margin: 0 -3px; 
        }

        /* Word Highlight (used for Tap-to-Meaning - blue/transparent) */
        .segment.show-tooltip {
            background-color: rgba(121, 166, 217, 0.4); 
            border-radius: 5px; 
            padding: 0 3px; 
            margin: 0 -3px; 
        }
        
        /* Tooltip (The Meaning) */
        .tooltip {
            visibility: hidden; position: absolute; background-color: #555;
            color: #fff; text-align: center; border-radius: 6px; padding: 8px 12px;
            z-index: 10; bottom: 125%; left: 50%; transform: translateX(-50%); 
            opacity: 0; transition: opacity 0.3s; font-size: 0.5em; white-space: nowrap;
        }
        
        /* Show tooltip only when the .show-tooltip class is present */
        .segment.show-tooltip .tooltip {
            visibility: visible; 
            opacity: 1; 
        }

        /* Input Field (Typing Bar) */
        .typing-input {
            width: 100%; padding: 12px; font-size: 1.1em; 
            border: none; 
            border-radius: 999px; 
            box-sizing: border-box; text-align: center;
            background-color: #333; color: var(--text-color);
        }
        /* Focus/Error feedback using box-shadow */
        .typing-input:focus { outline: none; box-shadow: 0 0 0 2px var(--primary-color); }
        .typing-input.correct { box-shadow: 0 0 0 2px var(--correct-color); background-color: #334433; }
        .typing-input.incorrect { box-shadow: 0 0 0 2px var(--incorrect-color); background-color: #443333; }
        .typing-input:focus.correct { box-shadow: 0 0 0 2px var(--correct-color); }
        .typing-input:focus.incorrect { box-shadow: 0 0 0 2px var(--incorrect-color); }


        .input-placeholder {
            width: 100%;
            padding: 15px;
            border-radius: 999px; 
            background-color: var(--primary-color);
            color: white;
            text-align: center;
            font-size: 1.2em;
            cursor: pointer;
            border: none;
        }

        /* --- Window 2: JSON Input Area --- */
        #json-input-window p { 
            text-align: center; 
            color: #aaa; 
            margin-bottom: 10px; 
            padding: 0 0; 
        }
        
        #json-paste-area {
            width: 100%; 
            height: 70vh; 
            padding: 10px;
            border: 2px dashed var(--border-color); border-radius: 8px;
            font-family: monospace; font-size: 0.9em; box-sizing: border-box; margin-bottom: 15px;
            background-color: #333; color: #ccc;
        }
        
        /* Button Group for JSON input window */
        .button-group { 
            display: flex; 
            gap: 10px; 
            padding: 0 0 20px 0; 
        }
        
        /* Button Group for fixed bar (when lesson is complete) */
        .button-group-fixed {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        /* Shared Button Styles */
        .button {
            flex-grow: 1; padding: 15px; font-size: 1em; font-weight: bold;
            border: none; 
            border-radius: 999px; 
            color: white; cursor: pointer;
            transition: transform 0.1s ease, background-color 0.2s;
        }
        .button:active { transform: none; } 
        
        /* Specific Button Colors */
        #copy-prompt-btn { background-color: var(--secondary-color); }
        #load-story-btn { background-color: var(--primary-color); }
        #repeat-lesson-btn { background-color: var(--secondary-color); } 
        #load-new-btn { background-color: var(--primary-color); } 


        /* Disabled state for button */
        .button:disabled {
            background-color: #444 !important;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }

        /* === Haptic + Shake feedback animation === */
        @keyframes shake {
          0% { transform: translateX(0); }
          20% { transform: translateX(-6px); }
          40% { transform: translateX(6px); }
          60% { transform: translateX(-4px); }
          80% { transform: translateX(4px); }
          100% { transform: translateX(0); }
        }

        .shake {
          animation: shake 0.3s ease;
        }
    </style>
</head>
<body>

    <div class="app-container">
        
        <div class="content-wrapper">
            
            <div class="window active tutorial" id="lesson-window">
                
                <div class="window-header" id="lesson-header" style="display: none;">
                    <span class="back-button" id="back-from-lesson-btn">&lt;</span>
                    <h2 id="current-lesson-title">Yaru Learning</h2> 
                    <span style="width: 2em; visibility: hidden;">&lt;</span> </div>
                
                <h1>Yaru Learning</h1>
                <h3 id="lesson-title">Lesson Generator Guide by Shafiullah</h3>
                
                <div id="sentence-container" class="sentence-display">
                    
                    <div id="tutorial-content">
                        <h5>How to Load a Lesson:</h5>
                        <p>You will use your favorite AI (ChatGPT, Gemini, Claude, etc.) to generate custom Japanese lessons.</p>
                        <ol>
                            <li>Tap the <strong>"Tap here to load a new lesson"</strong> button below.</li>
                            <li>On the next screen, tap <strong>"Copy Prompt"</strong> to copy the required prompt needed to generate a lesson.</li>
                            <li>Paste the prompt into your AI and ask it to generate a short story following the format.</li>
                            <li>Copy the resulting <strong>"JSON code"</strong> from the AI response.</li>
                            <li>Return to the app, tap the text area, and <strong>"paste the JSON code"</strong>.</li>
                            <li>Tap <strong>"Load Lesson"</strong> to begin practicing your new lesson!</li>
                        </ol>
                        <p>During practice, tap any Japanese word to see its English <strong>"meaning"</strong>.</p>
                    </div>
                    </div>
            </div>

            <div class="window" id="json-input-window">
                
                <div class="window-header">
                    <span class="back-button" id="back-from-json-btn">&lt;</span>
                    <h2>Yaru Learning</h2>
                    <span style="width: 2em; visibility: hidden;">&lt;</span> </div>

                <p>Generate a lesson with your favorite AI, then paste the JSON code below.</p>
                <textarea id="json-paste-area" placeholder="Paste your generated JSON here..."></textarea>
                <div class="button-group">
                    <button id="copy-prompt-btn" class="button">Copy Prompt</button>
                    <button id="load-story-btn" class="button" disabled>Load Lesson</button>
                </div>
            </div>

        </div> </div> 
        
    <div class="fixed-input-bar">
        <input type="text" id="user-input" class="typing-input" placeholder="ここにひらがなで入力" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" disabled style="display: none;">
        
        <div id="control-buttons" class="button-group-fixed" style="display: none;">
            <button id="repeat-lesson-btn" class="button">Repeat Lesson</button>
            <button id="load-new-btn" class="button">Load New Lesson</button>
        </div>
        
        <button id="load-prompt-placeholder" class="input-placeholder" style="display: block;">
            Tap here to load a new lesson
        </button>
    </div>
    <script>
    
    // --- Global TTS Variables ---
    const synth = window.speechSynthesis;
    let japaneseVoice = null;

    // === Haptic feedback helper ===
    function hapticFeedback(pattern = [40]) {
      // Mobile / tablet vibration API
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
      // For devices that support WebHaptics (Safari iOS 17+, Android Chrome)
      if ('HapticFeedback' in window) {
        try { window.HapticFeedback.vibrate(pattern); } catch (_) {}
      }
    }

    function populateVoiceList() {
        if (japaneseVoice) return;
        const voices = synth.getVoices();
        // Try to find a high-quality Google Japanese voice, otherwise fall back to any ja-JP voice
        japaneseVoice = voices.find(voice => voice.lang === 'ja-JP' && (voice.name.includes('Google') || voice.name.includes('Kyoko') || voice.name.includes('Otoya')));
        if (!japaneseVoice) {
            japaneseVoice = voices.find(voice => voice.lang.startsWith('ja'));
            if (!japaneseVoice) {
                console.warn('Japanese voice not found, speech feature may not function correctly.');
            }
        }
    }
    
    if (synth && synth.onvoiceschanged !== undefined) {
        synth.onvoiceschanged = populateVoiceList;
    }
    
    // --- NEW globals to prevent re-speaking ---
    let spokenSegments = new Set();   // track segments already spoken this lesson/session
    let speechToken = 0;             // cancels queued english utterances when new speech starts

    // --- Robust speech function (token-based) ---
    function isOnlyPunctuation(text) {
        return /^[\u3000-\u303F、。？！ー]*$/.test(text);
    }

    function adjustParticlePronunciation(segment) {
        // Only adjust if it's a single-character non-kanji segment (likely a particle)
        if (!segment.isKanji && segment.surface && segment.surface.length === 1) {
            if (segment.surface === "は") return "わ";
            if (segment.surface === "へ") return "え";
            if (segment.surface === "を") return "お";
        }
        // Prefer furigana when available (so multi-kana words speak correctly)
        return segment.furigana || segment.surface || '';
    }

    function speakSegment(segment) {
        if (!synth || !japaneseVoice) return;

        const furigana = segment.furigana || segment.surface || '';
        // 1) skip punctuation segments entirely
        if (isOnlyPunctuation(furigana)) return;

        // 2) build the Japanese text (with particle fixes when appropriate)
        const japaneseText = adjustParticlePronunciation(segment);
        const englishMeaning = segment.meaning || '';

        // 3) update token to cancel any pending english utterances from previous segments
        speechToken++;
        const thisToken = speechToken;

        // 4) cancel currently speaking/queued utterances to avoid overlaps
        synth.cancel();

        // 5) prepare and speak Japanese utterance
        const jp = new SpeechSynthesisUtterance(japaneseText);
        jp.voice = japaneseVoice;
        jp.lang = 'ja-JP';
        jp.rate = 1.0;
        jp.pitch = 1.0;

        // After jp finishes, speak english meaning only if token matches (no interception)
        jp.onend = () => {
            // If speechToken has changed, skip speaking the English meaning
            if (thisToken !== speechToken) return;
            if (!englishMeaning) return;

            // small short delay for natural pacing and to allow cancel to happen reliably
            setTimeout(() => {
                if (thisToken !== speechToken) return;
                const en = new SpeechSynthesisUtterance(englishMeaning);
                // attempt to choose an English voice if available (falls back to browser default)
                const voices = synth.getVoices();
                const enVoice = voices.find(v => v.lang && v.lang.startsWith('en'));
                if (enVoice) en.voice = enVoice;
                en.lang = 'en-US';
                en.rate = 0.9;
                en.pitch = 0.8;
                synth.speak(en);
            }, 120);
        };

        // speak Japanese now
        synth.speak(jp);
    }


    document.addEventListener('DOMContentLoaded', () => {
        
        // --- 1. Get References & Setup ---
        const lessonWindow = document.getElementById('lesson-window');
        const jsonInputWindow = document.getElementById('json-input-window');
        const loadPromptPlaceholder = document.getElementById('load-prompt-placeholder');
        const fixedInputBar = document.querySelector('.fixed-input-bar'); 
        const tutorialContent = document.getElementById('tutorial-content'); 
        
        // NEW: Header elements
        const lessonHeader = document.getElementById('lesson-header');
        const lessonHeaderTitle = document.getElementById('current-lesson-title');

        // Reference to the back buttons
        const backFromLessonBtn = document.getElementById('back-from-lesson-btn');
        const backFromJsonBtn = document.getElementById('back-from-json-btn'); 

        const lessonTitleEl = document.getElementById('lesson-title'); // The static H3 title
        const sentenceContainerEl = document.getElementById('sentence-container');
        const userInputEl = document.getElementById('user-input');
        
        const jsonPasteArea = document.getElementById('json-paste-area');
        const copyPromptBtn = document.getElementById('copy-prompt-btn');
        const loadStoryBtn = document.getElementById('load-story-btn');
        
        // Elements for lesson complete state
        const controlButtons = document.getElementById('control-buttons');
        const repeatLessonBtn = document.getElementById('repeat-lesson-btn');
        const loadNewBtn = document.getElementById('load-new-btn');

        // --- GLOBAL STATE VARIABLES ---
        let currentLessonData = null; 
        let currentSentenceIndex = 0; 
        let sentenceBlocks = [];

        // --- 2. Memory System Functions ---
        function saveLessonState() {
            if (currentLessonData) {
                localStorage.setItem('kakuLessonData', JSON.stringify(currentLessonData));
                localStorage.setItem('kakuSentenceIndex', currentSentenceIndex);
            }
        }

        function clearLessonState() {
            localStorage.removeItem('kakuLessonData');
            localStorage.removeItem('kakuSentenceIndex');
        }

        /**
         * Clears the sentence container and renders all lesson content.
         */
        function renderLessonContent(lessonData, startIndex) {
            // Set the dynamic title for the header
            if (lessonData.lessonTitle) {
                lessonHeaderTitle.textContent = lessonData.lessonTitle;
            } else {
                 lessonHeaderTitle.textContent = 'Yaru Learning';
            }
            
            sentenceContainerEl.innerHTML = ''; 
            
            lessonData.contentBlocks.filter(block => block.type === 'sentence').forEach((block, blockIndex) => {
                const sentenceDiv = document.createElement('div');
                sentenceDiv.classList.add('full-sentence'); 
                
                block.segments.forEach((segment, i) => {
                    const segmentSpan = document.createElement('span');
                    segmentSpan.classList.add('segment');

                    // IMPORTANT: stable id for tracking if this segment was already spoken
                    segmentSpan.dataset.segId = `${blockIndex}_${i}`;

                    const trailingSpace = (segment.surface.match(/[、。？！]/)) ? '' : ' ';

                    if (segment.isKanji) {
                        segmentSpan.innerHTML = `<ruby>${segment.surface}<rt>${segment.furigana}</rt></ruby>${trailingSpace}<span class="tooltip">${segment.meaning}</span>`;
                    } else {
                        segmentSpan.innerHTML = `${segment.surface}${trailingSpace}<span class="tooltip">${segment.meaning}</span>`;
                    }

                    // If this sentence is before the resume index, mark completed AND record it as spoken
                    if (blockIndex < startIndex) {
                        segmentSpan.classList.add('completed');
                        spokenSegments.add(segmentSpan.dataset.segId);
                    }

                    // Tap-to-meaning behavior (unchanged)
                    segmentSpan.addEventListener('click', function(e) {
                        e.stopPropagation();
                        const isAlreadyShowing = this.classList.contains('show-tooltip');
                        getAllSegments().forEach(s => s.classList.remove('show-tooltip'));
                        if (!isAlreadyShowing) {
                            this.classList.add('show-tooltip');
                        }
                    });

                    sentenceDiv.appendChild(segmentSpan);
                });
                
                sentenceContainerEl.appendChild(sentenceDiv);
            });
        }

        function loadSavedLesson() {
            const savedData = localStorage.getItem('kakuLessonData');
            const savedIndex = localStorage.getItem('kakuSentenceIndex');
            
            if (savedData && savedIndex !== null) {
                try {
                    const lessonData = JSON.parse(savedData);
                    const startIndex = parseInt(savedIndex, 10);
                    
                    currentLessonData = lessonData;
                    sentenceBlocks = lessonData.contentBlocks.filter(block => block.type === 'sentence');
                    currentSentenceIndex = startIndex;
                    
                    renderLessonContent(lessonData, startIndex);
                    tutorialContent.style.display = 'none';

                    // Switch to lesson view state: show the new header with back button
                    lessonWindow.classList.remove('tutorial');
                    lessonHeader.style.display = 'flex'; 

                    // Ensure correct visibility states are set on resume
                    loadPromptPlaceholder.style.display = 'none';
                    userInputEl.style.display = 'block';
                    controlButtons.style.display = 'none'; 
                    
                    setupNextSentence();
                    setWindow('lesson');
                    
                    return true;
                    
                } catch (e) {
                    clearLessonState();
                    return false;
                }
            }
            return false;
        }

        // --- 3. Utility Functions ---
        
        function setWindow(windowId) {
            if (windowId === 'lesson') {
                lessonWindow.classList.add('active');
                jsonInputWindow.classList.remove('active');
                fixedInputBar.style.display = 'flex'; 

                setTimeout(() => {
                    if (!userInputEl.disabled) {
                        userInputEl.focus();
                    }
                }, 100);
            } else if (windowId === 'json') {
                lessonWindow.classList.remove('active');
                jsonInputWindow.classList.add('active');
                fixedInputBar.style.display = 'none'; 
            }
        }
        
        // NEW: Function to return to the initial tutorial state (hides back button)
        function showTutorial() {
            currentLessonData = null;
            clearLessonState();
            
            // Show tutorial content
            tutorialContent.style.display = 'block'; 
            lessonTitleEl.textContent = 'Lesson Generator Guide by Shafiullah'; 
            sentenceContainerEl.innerHTML = document.getElementById('tutorial-content').outerHTML;

            // Update UI state to tutorial: Hides the new header/back button, shows static titles
            lessonWindow.classList.add('tutorial'); 
            lessonHeader.style.display = 'none'; 
            
            // Show placeholder and hide input
            userInputEl.style.display = 'none'; 
            controlButtons.style.display = 'none'; 
            loadPromptPlaceholder.style.display = 'block';
            
            setWindow('lesson');
        }

        function getAllSegments() {
            return sentenceContainerEl.querySelectorAll('.segment');
        }

        function getCurrentSentenceSegments() {
            const currentSentenceDiv = sentenceContainerEl.querySelectorAll('.full-sentence')[currentSentenceIndex];
            if (currentSentenceDiv) {
                return currentSentenceDiv.querySelectorAll('.segment');
            }
            return [];
        }

        const aiPrompt = `
Generate a JSON object for a short Japanese lesson. The lesson should contain one or more sentences.

Follow this JSON structure EXACTLY:

{
  "lessonTitle": "A creative title for the lesson",
  "contentBlocks": [
    {
      "type": "sentence",
      "id": "s1",
      "segments": [
        {
          "surface": "The Japanese word or particle (e.g., '私' or 'は')",
          "furigana": "The hiragana reading (e.g., 'わたし' or 'は')",
          "romaji": "The romaji reading (e.g., 'watashi' or 'wa')",
          "meaning": "The English meaning",
          "isKanji": true
        }
      ]
    }
  ]
}

- "surface": The text to display.
- "furigana": The reading that goes above the text. For hiragana/katakana, this is the same as the surface.
- "isKanji": Must be a boolean (true if the surface is Kanji that needs furigana, otherwise false).

Example of a correct segment for the kanji '学校':
{
  "surface": "学校",
  "furigana": "がっこう",
  "romaji": "gakkou",
  "meaning": "school",
  "isKanji": true
}

Now, generate a new, complete JSON object for a short story of about 3-4 sentences (like the one in the user's image) so the content blocks array has multiple sentence objects.
`;

        // --- 4. Core App Functions ---
        
        function setupNextSentence() {
            if (currentSentenceIndex >= sentenceBlocks.length) {
                // Lesson complete!
                userInputEl.placeholder = "Great Job! Tap 'Repeat' or 'Load New Lesson'";
                userInputEl.classList.add('correct');
                userInputEl.disabled = true; 
                
                // Show control buttons and hide input when done
                controlButtons.style.display = 'flex';
                loadPromptPlaceholder.style.display = 'none'; 
                userInputEl.style.display = 'none'; 
                
                clearLessonState(); // Lesson finished, clear memory
                return;
            }

            spokenSegments.clear();

            const currentBlock = sentenceBlocks[currentSentenceIndex];
            const targetHiragana = currentBlock.segments.map(s => s.furigana).join('');

            // Reset input and set new target
            userInputEl.value = '';
            userInputEl.classList.remove('correct', 'incorrect');
            userInputEl.setAttribute('data-target', targetHiragana);
            userInputEl.disabled = false;
            userInputEl.placeholder = 'ここにひらがなで入力';
            userInputEl.focus(); 
            
            getAllSegments().forEach(s => s.classList.remove('show-tooltip'));
        }

        function renderLesson(lessonData) {
            currentLessonData = lessonData;
            sentenceBlocks = lessonData.contentBlocks.filter(block => block.type === 'sentence');
            currentSentenceIndex = 0; 
            
            saveLessonState(); 
            renderLessonContent(lessonData, 0); 
            tutorialContent.style.display = 'none';

            // Switch to active lesson view state: show the new header with back button
            lessonWindow.classList.remove('tutorial');
            lessonHeader.style.display = 'flex'; 

            // Show input field, hide control buttons/placeholder
            loadPromptPlaceholder.style.display = 'none';
            controlButtons.style.display = 'none'; 
            userInputEl.style.display = 'block';
            
            setupNextSentence();
            setWindow('lesson');
        }

        function handleTyping(event) {
            const typedText = event.target.value;
            const targetHiragana = event.target.getAttribute('data-target');
            if (!targetHiragana || event.target.disabled) return;

            const currentSegments = getCurrentSentenceSegments();
            if (!currentSegments || currentSegments.length === 0) return;

            // feedback classes
            userInputEl.classList.remove('correct', 'incorrect');

            const currentBlock = sentenceBlocks[currentSentenceIndex];
            let tempLength = 0;

            for (let i = 0; i < currentBlock.segments.length; i++) {
                const segmentData = currentBlock.segments[i];
                const segEl = currentSegments[i];
                const segStart = tempLength;
                tempLength += segmentData.furigana.length;
                const segEnd = tempLength;
                const segId = segEl.dataset.segId;

                // If user has typed past the end of this segment -> completed
                if (typedText.length >= segEnd) {
                    segEl.classList.remove('correct');
                    segEl.classList.add('completed');

                    // If not spoken yet, speak it once and record it
                    if (!spokenSegments.has(segId) && !isOnlyPunctuation(segmentData.furigana)) {
                        spokenSegments.add(segId);
                        speakSegment(segmentData); 
                    }
                }
                // Partially typed this segment
                else if (typedText.length > segStart && typedText.length <= segEnd) {
                    segEl.classList.add('correct');
                }
                // Not reached this segment yet
                else {
                    segEl.classList.remove('correct');
                    // Do not remove .completed if it was already completed
                }
            }

            // Check full sentence completion
            if (typedText === targetHiragana) {
                // Stop any ongoing speech and move to next
                if (synth.speaking) synth.cancel();

                currentSegments.forEach(seg => {
                    seg.classList.remove('correct');
                    seg.classList.add('completed');
                    spokenSegments.add(seg.dataset.segId);
                });

                currentSentenceIndex++;
                saveLessonState();
                setupNextSentence();
            } else {
                // Provide quick visual feedback while typing
                if (targetHiragana.startsWith(typedText)) {
                    if (typedText.length > 0) userInputEl.classList.add('correct');
                } else {
                    // Wrong input feedback
                    userInputEl.classList.add('incorrect');
                    userInputEl.classList.add('shake');
                    hapticFeedback([30, 40, 30]); // short vibration pattern

                    // Remove the shake class after animation ends
                    setTimeout(() => userInputEl.classList.remove('shake'), 300);
                }
            }
        }


        // --- 5. Event Listeners ---

        loadPromptPlaceholder.addEventListener('click', () => {
            setWindow('json');
        });

        loadNewBtn.addEventListener('click', () => {
            setWindow('json');
        });
        
        // **FIXED LOGIC**: Back button from lesson (goes to JSON input)
        backFromLessonBtn.addEventListener('click', () => {
            setWindow('json');
        });

        // Back button from JSON (goes back to lesson, or tutorial if no lesson loaded)
        backFromJsonBtn.addEventListener('click', () => {
            if (currentLessonData) {
                setWindow('lesson');
            } else {
                showTutorial();
            }
        });

        repeatLessonBtn.addEventListener('click', () => {
            if (currentLessonData) {
                renderLesson(currentLessonData); 
                controlButtons.style.display = 'none'; 
            }
        });

        copyPromptBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(aiPrompt.trim())
                .then(() => {
                    copyPromptBtn.textContent = 'Copied!';
                    copyPromptBtn.style.backgroundColor = 'var(--correct-color)';
                    setTimeout(() => { 
                        copyPromptBtn.textContent = 'Copy Prompt'; 
                        copyPromptBtn.style.backgroundColor = 'var(--secondary-color)';
                    }, 2000);
                })
                .catch(err => {
                    alert('Failed to copy prompt.');
                });
        });
        
        jsonPasteArea.addEventListener('input', () => {
            if (jsonPasteArea.value.trim().length > 0) {
                loadStoryBtn.disabled = false;
                loadStoryBtn.style.backgroundColor = 'var(--primary-color)'; 
            } else {
                loadStoryBtn.disabled = true;
                loadStoryBtn.style.backgroundColor = ''; 
            }
        });

        loadStoryBtn.addEventListener('click', () => {
            const jsonText = jsonPasteArea.value;
            if (!jsonText.trim()) {
                alert('Please paste the generated JSON code first.');
                return;
            }
            try {
                const parsedJson = JSON.parse(jsonText);
                if (parsedJson.contentBlocks && parsedJson.contentBlocks.length > 0) {
                    renderLesson(parsedJson); 
                    jsonPasteArea.value = ''; 
                    loadStoryBtn.disabled = true; 
                } else {
                    alert('Error: The JSON is missing the required "contentBlocks".');
                }
            } catch (error) {
                alert('Error: The pasted text is not valid JSON. Please check the code and try again.\n\nDetails: ' + error.message);
            }
        });

        userInputEl.addEventListener('input', handleTyping);

        // --- 6. Initial State & Load Check ---
        populateVoiceList(); 
        const lessonLoaded = loadSavedLesson(); 

        if (!lessonLoaded) {
            // Default initial state (showing tutorial)
            showTutorial(); 
        }

        fixedInputBar.style.display = 'flex';
        loadStoryBtn.disabled = true;

        // === Apply gentle haptic feedback to all interactive buttons ===
        document.querySelectorAll('button, #back-from-lesson-btn, #back-from-json-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            hapticFeedback(20); // single short vibration
          });
        });

    });
    </script>
</body>
</html>
